{"version":3,"file":"index.js","sources":["../../src/useAutoScroll/useAutoScroll.ts","../../src/useViewportSize.ts","../../src/useAvailableSpace.ts","../../src/useEventListener.ts","../../src/useBackdropClick.ts","../../src/useControlledValue/useControlledValue.ts","../../src/useDynamicRefs/index.ts","../../src/useEscapeKey.ts","../../src/useForceRerender/useForceRerender.tsx","../../src/useForwardedRef.tsx","../../src/useIdAllocator.ts","../../src/useIsomorphicLayoutEffect.ts","../../src/useMutationObserver.ts","../../src/useObjectDependency.ts","../../src/usePoller.ts","../../src/usePrevious.ts","../../src/useStateRef.ts","../../src/useValidation.tsx"],"sourcesContent":["import { RefObject, useEffect } from 'react';\n\n/**\n * Automatically scrolls the container to\n * ensure the elementRef is always at the top of the container.\n *\n * Required styles:\n * ```css\n * .container-parent {\n *    position: relative | absolute;\n * }\n *\n * .container {\n *    position: relative;\n *    max-height: {number};\n *    overflow: auto;\n * }\n *\n * .element {\n *    position: relative;\n *    height: {number}\n * }\n * ```\n */\nexport const useAutoScroll = (\n  /**\n   * The element to keep at the top\n   */\n  elementRef?: RefObject<HTMLElement>,\n  /**\n   * The container element\n   */\n  containerRef?: RefObject<HTMLElement>,\n  /**\n   * A vertical offset amount to account for padding/margin\n   */\n  offset = 0,\n) => {\n  // When the focused option changes, update the menu scroll if necessary\n  useEffect(() => {\n    if (\n      elementRef &&\n      elementRef.current &&\n      containerRef &&\n      containerRef.current\n    ) {\n      const { offsetTop: elementTop } = elementRef.current;\n      const { scrollTop: containerTop, offsetHeight: containerHeight } =\n        containerRef.current;\n\n      if (elementTop > containerHeight || elementTop < containerTop) {\n        containerRef.current.scrollTo({\n          top: elementTop - offset,\n          behavior: 'smooth', // TODO: update this based on prefers-reduced-motion\n        });\n      }\n    }\n  }, [containerRef, elementRef, offset]);\n};\n","import { useEffect, useState } from 'react';\nimport debounce from 'lodash/debounce';\n\ninterface ViewportSize {\n  width: number;\n  height: number;\n}\n\nfunction getViewportSize(): ViewportSize {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nexport default function useViewportSize(): ViewportSize | null {\n  const [viewportSize, setViewportUpdateVal] = useState<ViewportSize | null>(\n    null,\n  );\n\n  useEffect(() => {\n    setViewportUpdateVal(getViewportSize());\n\n    const calcResize = debounce(\n      () => setViewportUpdateVal(getViewportSize()),\n      100,\n    );\n\n    window.addEventListener('resize', calcResize);\n\n    return () => window.removeEventListener('resize', calcResize);\n  }, []);\n\n  return viewportSize;\n}\n","import { useMemo } from 'react';\n\nimport useViewportSize from './useViewportSize';\n\n/**\n * Returns the maximum space available above or below the source trigger\n * @param triggerRef The `ref` object attached to the source trigger\n * @param margin The space around the trigger\n */\nconst useAvailableSpace = (\n  triggerRef?: React.RefObject<HTMLElement>,\n  margin = 8,\n) => {\n  const viewportSize = useViewportSize();\n\n  return useMemo(() => {\n    if (viewportSize && triggerRef && triggerRef.current) {\n      // Get the top & bottom coordinates of the trigger\n      const { top: triggerTop, bottom: triggerBottom } =\n        triggerRef.current.getBoundingClientRect();\n\n      // Find out how much space is available above or below the trigger\n      const safeSpace = Math.max(\n        viewportSize.height - triggerBottom,\n        triggerTop,\n      );\n\n      // Return to fill the space available\n      return safeSpace - margin;\n    }\n  }, [viewportSize, triggerRef, margin]);\n};\n\nexport default useAvailableSpace;\n","import { useEffect, useRef } from 'react';\n\nexport interface UseEventOptions {\n  options?: Omit<AddEventListenerOptions, 'once'>;\n  dependencies?: Array<any>;\n  enabled?: boolean | 'once';\n  element?: Document | HTMLElement;\n}\n\n/**\n * Hook to subscribe to an event listener.\n * @param type Represents the event type to listen for.\n * @param eventCallback Event listener callback function.\n * @param optional Optional third argument passed to function with implementation specifications\n * @param optional.options Parameter to specify options passed to the eventListener.\n * @param optional.enabled Determines whether or not the useEffect hook should run.\n * @param optional.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.\n * @param optional.element Value to be passed as target of event handler, will default to document.\n */\nexport default function useEventListener<Type extends keyof DocumentEventMap>(\n  type: Type,\n  eventCallback: (e: DocumentEventMap[Type]) => void,\n  {\n    options,\n    enabled = true,\n    dependencies = [enabled, type],\n    element,\n  }: UseEventOptions = {},\n) {\n  const memoizedEventCallback: React.MutableRefObject<\n    (e: DocumentEventMap[Type]) => void\n  > = useRef(() => {});\n\n  useEffect(() => {\n    memoizedEventCallback.current = eventCallback;\n  }, [eventCallback]);\n\n  useEffect(() => {\n    if (enabled === false) {\n      return;\n    }\n\n    // Handle this in case non-TypeScript users pass in the wrong value\n    if (enabled !== 'once' && enabled !== true) {\n      console.error(\n        `Received value of type ${typeof enabled} for property \\`enabled\\`. Expected a boolean.`,\n      );\n      return;\n    }\n\n    const callback = (e: DocumentEventMap[Type]) => {\n      memoizedEventCallback.current(e);\n    };\n\n    const eventListenerOptions = {\n      ...options,\n      once: enabled === 'once',\n    };\n\n    // NOTE(JeT): I'm pretty sure there should be a way to avoid this type assertion, but I couldn't figure it out.\n    (element ?? document).addEventListener(\n      type,\n      callback as EventListener,\n      eventListenerOptions,\n    );\n\n    return () => {\n      (element ?? document).removeEventListener(\n        type,\n        callback as EventListener,\n        eventListenerOptions,\n      );\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n","import useEventListener from './useEventListener';\n\n/**\n * Fires a callback when any element(s)\n * _except_ those passed in as `foreground` is clicked.\n *\n * Note: Disable this hook (with the `enabled` arg)\n * if the `foreground` element(s) are not in view (e.g. menu, tooltip, etc.).\n */\nexport function useBackdropClick(\n  /**\n   * Function called when any element other than those provided is clicked\n   */\n  callback: Function,\n\n  /**\n   * The primary element(s) that are excluded from backdrop click\n   */\n  foreground:\n    | React.RefObject<HTMLElement>\n    | Array<React.RefObject<HTMLElement>>,\n\n  /**\n   * Whether the callback is enabled.\n   * It's recommended to set this to `false` when not in use,\n   * and toggle to `true` when the main elements (menu, tooltip, etc) are visible\n   */\n  enabled = true,\n): void {\n  /**\n   * We add two event handlers to the document to handle the backdrop click behavior.\n   * Intended behavior is to fire the callback (usually closing a menu, tooltip, etc.),\n   * and keep focus on the component.\n   *\n   * No other click event handlers should fire on backdrop click\n   *\n   * 1. Mousedown event fires\n   * 2. We prevent `mousedown`'s default behavior, to prevent focus from being applied to the body (or other target)\n   * 3. Click event fires\n   * 4. We handle this event on _capture_, and stop propagation before the `click` event propagates all the way to any other element.\n   *  This ensures that even if we click on a button, that handler is not fired\n   * 5. Then we call the callback (typically fires `closeMenu`, setting `isOpen = false`, and rerender the component)\n   */\n\n  useEventListener(\n    'mousedown',\n    (mousedown: MouseEvent) => {\n      if (!doesComponentContainEventTarget(mousedown)) {\n        mousedown.preventDefault(); // Prevent focus from being applied to body\n        mousedown.stopPropagation(); // Stop any other mousedown events from firing\n      }\n    },\n    {\n      enabled,\n    },\n  );\n\n  useEventListener(\n    'click',\n    (click: MouseEvent) => {\n      if (!doesComponentContainEventTarget(click)) {\n        click.stopPropagation(); // Stop any other click events from firing\n        callback();\n      }\n    },\n    {\n      options: { capture: true },\n      enabled,\n    },\n  );\n\n  /**\n   * Returns whether the event target within the component\n   */\n  function doesComponentContainEventTarget({ target }: MouseEvent): boolean {\n    return Array.isArray(foreground)\n      ? foreground.some(ref => ref.current?.contains(target as Node))\n      : foreground.current?.contains(target as Node) || false;\n  }\n}\n","import {\n  ChangeEventHandler,\n  MutableRefObject,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\nimport isUndefined from 'lodash/isUndefined';\n\nimport { consoleOnce, createSyntheticEvent } from '@leafygreen-ui/lib';\n\ninterface ControlledValueReturnObject<T extends any> {\n  /** Whether the value is controlled */\n  isControlled: boolean;\n\n  /** The controlled or uncontrolled value */\n  value: T;\n\n  /** A ChangeEventHandler to assign to any onChange event */\n  handleChange: ChangeEventHandler<any>;\n\n  /**\n   * A setter for the internal value.\n   * Does not change the controlled value if the provided value has not changed.\n   * Prefer using `updateValue` to programmatically set the value.\n   * @internal\n   */\n  setUncontrolledValue: React.Dispatch<React.SetStateAction<T>>;\n\n  /**\n   * Synthetically triggers a change event within the `handleChange` callback.\n   * Signals that the value should change for controlled components,\n   * and updates the internal value for uncontrolled components\n   */\n  updateValue: (newVal: T, ref: MutableRefObject<any>) => void;\n}\n\n/**\n * A hook that enables a component to be both controlled or uncontrolled.\n *\n * Returns a {@link ControlledValueReturnObject} with the controlled or uncontrolled `value`,\n * `onChange` & `onClear` handlers, a `setInternalValue` setter, and a boolean `isControlled`\n */\nexport const useControlledValue = <T>(\n  controlledValue?: T,\n  changeHandler?: ChangeEventHandler<any> | null,\n  initialValue?: T,\n): ControlledValueReturnObject<T | undefined> => {\n  // isControlled should only be computed once\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const isControlled = useMemo(() => !isUndefined(controlledValue), []);\n\n  // Keep track of the uncontrolled value state internally\n  const [uncontrolledValue, setUncontrolledValue] = useState<T | undefined>(\n    initialValue,\n  );\n\n  // Create a change event handler that either updates the internal state\n  // or fires an external change handler\n  const handleChange: ChangeEventHandler<any> = e => {\n    changeHandler?.(e);\n    if (!isControlled) {\n      setUncontrolledValue(e.target.value as T);\n    }\n  };\n\n  // A wrapper around `handleChange` that fires a simulated event\n  const updateValue = (newVal: T | undefined, ref: MutableRefObject<any>) => {\n    if (ref.current) {\n      ref.current.value = newVal;\n      const synthEvt = createSyntheticEvent(\n        new Event('change', {\n          cancelable: true,\n          bubbles: true,\n        }),\n        ref.current,\n      );\n\n      handleChange(synthEvt);\n    }\n  };\n\n  useEffect(() => {\n    // Log a warning if neither controlled value or initialValue is provided\n    if (isUndefined(controlledValue) && isUndefined(initialValue)) {\n      consoleOnce.error(\n        `Warning: \\`useControlledValue\\` hook is being used without a value or initialValue. This will cause a React warning when the input changes. Please decide between using a controlled or uncontrolled input element, and provide either a controlledValue or initialValue to \\`useControlledValue\\``,\n      );\n    }\n  }, [controlledValue, initialValue]);\n\n  return {\n    isControlled,\n    value: isControlled ? controlledValue : uncontrolledValue,\n    handleChange,\n    setUncontrolledValue,\n    updateValue,\n  };\n};\n","/**\n * Based on https://github.com/fitzmode/use-dynamic-refs/blob/master/src/index.tsx\n */\n\nimport * as React from 'react';\n\nimport { consoleOnce } from '@leafygreen-ui/lib';\n\nexport interface UseDynamicRefsArgs {\n  prefix: string;\n}\n\n/** The Map type for a given ref object  */\nexport type RefMap<T> = Map<string, React.RefObject<T>>;\n\n/**\n * @internal\n */\nexport function getGetRef<T>(refMap: RefMap<T>) {\n  /**\n   * Returns a ref (or creates a new one) for the provided key\n   */\n  function getRef(): undefined;\n  function getRef(key: string): React.RefObject<T>;\n  function getRef(key?: string): React.RefObject<T> | undefined {\n    if (!key) {\n      consoleOnce.error('`useDynamicRefs`: Cannot get ref without key');\n      return;\n    }\n\n    if (refMap.get(key)) {\n      return refMap.get(key) as React.RefObject<T>;\n    }\n\n    const ref = React.createRef<T>();\n    refMap.set(key, ref);\n    return ref;\n  }\n\n  return getRef;\n}\n\n/** The function signature for the function returned by `useDynamicRefs` */\nexport type DynamicRefGetter<T> = ReturnType<typeof getGetRef<T>>;\n\n/**\n * Returns a ref \"getter\" function for the specified namespace (prefix).\n *\n * Calling the ref \"getter\" with a key will return a ref for the given namespace and key\n */\nexport function useDynamicRefs<T>(\n  args?: UseDynamicRefsArgs,\n): DynamicRefGetter<T> {\n  const prefix = args?.prefix;\n\n  const getRef = React.useMemo(() => {\n    const refMap: RefMap<T> = new Map<string, React.RefObject<T>>();\n    const getter = getGetRef<T>(refMap);\n    return getter;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [prefix]);\n\n  return getRef;\n}\n","import useEventListener, { UseEventOptions } from './useEventListener';\n\nconst escapeKeyCode = 27;\n\nconst handleEscape = (e: KeyboardEvent, callback: () => void) => {\n  if (e.keyCode === escapeKeyCode) {\n    e.stopImmediatePropagation();\n    callback();\n  }\n};\n\n/**\n * Hook to subscribe to an escape-key-press.\n * @param callback Callback function to be executed when Escape key is pressed.\n * @param options Object to refine when callback is invoked.\n * @param options.options Parameter to specify options passed to the eventListener.\n * @param options.enabled Determines whether or not the useEffect hook should run.\n * @param options.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.\n * @param options.element Value to be passed as target of event handler, will default to document.\n */\nconst useEscapeKey = (callback: () => void, options?: UseEventOptions) => {\n  return useEventListener('keydown', e => handleEscape(e, callback), options);\n};\n\nexport default useEscapeKey;\n","import { useCallback, useState } from 'react';\n\n/**\n * Hook that forces a re-render.\n */\nexport function useForceRerender(): () => void {\n  const [, updateState] = useState<Object>({});\n  const forceRerender = useCallback(() => updateState({}), []);\n\n  return forceRerender;\n}\n","import { useCallback, useMemo, useRef } from 'react';\n\n// Ported from Select/utils\n// TODO: - remove duplicated code from Select/utils\nexport function useObservedRef<T>(\n  callback: (value: T) => void,\n  initialValue: T,\n  options: { initialValue: T; deps?: React.DependencyList },\n): React.MutableRefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T) => void,\n  options?: { initialValue: T | null; deps?: React.DependencyList },\n): React.RefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T | undefined) => void,\n  options?: { deps?: React.DependencyList },\n): React.MutableRefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T | null | undefined) => void,\n  {\n    initialValue,\n    deps = [],\n  }: { initialValue?: T | null; deps?: React.DependencyList } = {},\n) {\n  const ref = useRef(initialValue);\n\n  return useMemo(\n    () => ({\n      get current() {\n        return ref.current;\n      },\n      set current(nextValue) {\n        ref.current = nextValue;\n        callback(nextValue);\n      },\n    }),\n    [\n      callback,\n      ref,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      ...deps,\n    ],\n  );\n}\n\ntype SettableRef<T> = React.RefCallback<T> | React.MutableRefObject<T>;\n\ntype ValueOrArray<T> = T | ReadonlyArray<T>;\n\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>,\n  initialValue: T,\n): React.MutableRefObject<T>;\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T | null> | null>,\n  initialValue: T | null,\n): React.RefObject<T>;\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T | null | undefined> | null>,\n  initialValue?: T | null,\n): React.MutableRefObject<T | null | undefined> {\n  const forwardValueToRefs = useCallback(\n    <T,>(\n      forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>,\n      nextValue: T,\n    ) => {\n      if (Array.isArray(forwardedRefOrRefs)) {\n        forwardedRefOrRefs.forEach(forwardValueToRefs);\n      } else if (typeof forwardedRefOrRefs === 'function') {\n        forwardedRefOrRefs(nextValue);\n      } else if (forwardedRefOrRefs) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/40527\n        forwardedRefOrRefs.current = nextValue;\n      }\n    },\n    [],\n  );\n\n  return useObservedRef(\n    useCallback(\n      value => forwardValueToRefs(forwardedRefOrRefs, value),\n      [forwardedRefOrRefs, forwardValueToRefs],\n    ),\n    { initialValue },\n  );\n}\n","// Currently using Material UI useId hook until we can upgrade to React 18's useId\n// https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/useId.ts\nimport { useEffect, useState } from 'react';\n\ninterface Params {\n  prefix?: string;\n  id?: string;\n}\n\nlet globalId = 0;\n\nfunction useGlobalId({ id: idOverride, prefix }: Params): string {\n  const [defaultId, setDefaultId] = useState<string | number | undefined>(\n    idOverride,\n  );\n\n  useEffect(() => {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the incrementing value for client-side rendering only.\n      // We can't use it server-side.\n      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem\n      globalId += 1;\n      setDefaultId(globalId);\n    }\n  }, [defaultId, prefix]);\n\n  return idOverride ? idOverride : `${prefix ?? 'lg'}-${defaultId}`;\n}\n\nexport default function useId({ prefix, id: idOverride }: Params): string {\n  // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.\n  return useGlobalId({ id: idOverride, prefix });\n}\n","import { useEffect, useLayoutEffect } from 'react';\n\nconst useIsomorphicLayoutEffect: typeof useLayoutEffect = (...args) => {\n  const effectHook =\n    typeof window === 'undefined' ? useEffect : useLayoutEffect;\n  return effectHook(...args);\n};\n\nexport default useIsomorphicLayoutEffect;\n","import { useEffect, useState } from 'react';\n\ntype MutationHandler<Value> = (\n  mutations: Array<MutationRecord>,\n  observer: MutationObserver,\n) => Value;\n\n/**\n * Hook to subscribe to changes on the DOM.\n * @param target HTML element that is subscribed to DOM changes.\n * @param options Object with information about what DOM changes to subscribe to.\n * @param callback Callback function to execute inside of MutationObserver instance.\n * @param enabled Determines whether or not the hook should run, defaults to true.\n */\nexport default function useMutationObserver<Value>(\n  target: HTMLElement | null,\n  options: MutationObserverInit,\n  callback: MutationHandler<Value>,\n  enabled = true,\n): Value | undefined {\n  const [value, setValue] = useState<Value>();\n\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const observer = new MutationObserver((...args) => {\n      setValue(callback(...args));\n    });\n\n    if (target) {\n      observer.observe(target, options);\n    }\n\n    return () => observer.disconnect();\n  }, [target, options, callback, enabled]);\n\n  return value;\n}\n","import { useRef } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nexport default function useObjectDependency<T>(object: T): T {\n  const ref = useRef<T>();\n\n  // we need isEqual for deep object comparison\n  if (ref.current === undefined || !isEqual(ref.current, object)) {\n    ref.current = object;\n  }\n\n  return ref.current;\n}\n","import { useEffect, useRef, useState } from 'react';\n\nimport useEventListener from './useEventListener';\n\nfunction useVisibilityChange() {\n  const isVisibilityStateVisible = () => document.visibilityState === 'visible';\n\n  const [isVisible, setIsVisible] = useState(true);\n\n  useEffect(() => {\n    setIsVisible(isVisibilityStateVisible);\n  }, []);\n\n  useEventListener('visibilitychange', () => {\n    setIsVisible(isVisibilityStateVisible);\n  });\n\n  return isVisible;\n}\n\ntype OnPoll = () => void;\n\ninterface PollerOptions {\n  /**\n   * How frequently should we call the onPoll handler. Defaults to 30 seconds.\n   * @default 30000\n   */\n  interval?: number;\n\n  /**\n   * Should we immediately trigger the onPoll handler.\n   * @default true\n   */\n  immediate?: boolean;\n\n  /**\n   * Should we be polling.\n   * @default true\n   */\n  enabled?: boolean;\n}\n\nexport default function usePoller(\n  onPoll: OnPoll,\n  { interval = 30e3, immediate = true, enabled = true }: PollerOptions = {},\n) {\n  const savedCallback = useRef<OnPoll>();\n  const isVisible = useVisibilityChange();\n\n  const isPolling = isVisible && enabled;\n\n  useEffect(() => {\n    savedCallback.current = onPoll;\n  });\n\n  useEffect(() => {\n    if (!isPolling) {\n      return;\n    }\n\n    // Using this reflection to get return type of setTimeout so we don't have to\n    // use window.setTimeout, makes this more cross-environment compatible\n    // Sourced from: https://stackoverflow.com/a/51040768\n    let id: ReturnType<typeof setTimeout>;\n\n    function scheduleNextPoll() {\n      unscheduleNextPoll();\n      id = setTimeout(poll, interval);\n    }\n\n    function unscheduleNextPoll() {\n      clearTimeout(id);\n    }\n\n    function poll() {\n      Promise.resolve(savedCallback.current?.()).finally(scheduleNextPoll);\n    }\n\n    if (immediate) {\n      poll();\n    } else {\n      scheduleNextPoll();\n    }\n\n    return unscheduleNextPoll;\n  }, [interval, immediate, isPolling]);\n}\n","import { useEffect, useRef } from 'react';\n\n/**\n * Hook to store previous props\n * https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state\n */\nexport default function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n","import { useCallback, useRef, useState } from 'react';\n\n/**\n *\n * A combination of useState and useRef,\n * returns the current state, a `setState` and a `getState` function.\n *\n * Use the `getState` function inside an event listener callbacks\n * in order to avoid referencing a stale state\n *\n * @param initial\n * @returns [state, setState, getState]\n */\nexport function useStateRef<T extends any>(\n  initial: T,\n): [T, (x: T) => void, () => T] {\n  const [state, _setState] = useState<T>(initial);\n  const ref = useRef<T>(state);\n\n  const setState = useCallback(\n    (newVal: T): void => {\n      _setState(newVal);\n      ref.current = newVal;\n    },\n    [_setState],\n  );\n\n  const getState = useCallback((): T => {\n    return ref.current;\n  }, []);\n\n  return [state, setState, getState];\n}\n","import { useState } from 'react';\nimport isUndefined from 'lodash/isUndefined';\n\nexport default function useValidation<\n  T extends HTMLInputElement | HTMLTextAreaElement,\n>(handleValidation?: (value: string) => void) {\n  const [isDirty, setIsDirty] = useState(false);\n\n  if (isUndefined(handleValidation) || typeof handleValidation !== 'function') {\n    return {\n      onBlur: () => {},\n      onChange: () => {},\n    };\n  }\n\n  const onBlur = (e: React.FocusEvent<T>) => {\n    setIsDirty(true);\n    handleValidation?.(e.target.value);\n  };\n\n  const onChange = (e: React.ChangeEvent<T>) => {\n    if (isDirty) {\n      handleValidation?.(e.target.value);\n    }\n  };\n\n  return {\n    onBlur,\n    onChange,\n  };\n}\n"],"names":["useAutoScroll","elementRef","containerRef","offset","arguments","length","undefined","useEffect","current","elementTop","offsetTop","_containerRef$current","containerTop","scrollTop","offsetHeight","scrollTo","top","behavior","getViewportSize","width","window","innerWidth","height","innerHeight","useViewportSize","_useState2","_slicedToArray","useState","viewportSize","setViewportUpdateVal","calcResize","debounce","addEventListener","removeEventListener","useAvailableSpace","triggerRef","margin","useMemo","_triggerRef$current$g","getBoundingClientRect","triggerTop","triggerBottom","bottom","Math","max","useEventListener","type","eventCallback","_ref","options","_ref$enabled","enabled","_ref$dependencies","dependencies","element","memoizedEventCallback","useRef","callback","e","eventListenerOptions","_objectSpread","once","document","console","error","concat","_typeof","useBackdropClick","foreground","doesComponentContainEventTarget","_foreground$current","target","Array","isArray","some","ref","_ref$current","contains","mousedown","preventDefault","stopPropagation","click","capture","useControlledValue","controlledValue","changeHandler","initialValue","isControlled","isUndefined","uncontrolledValue","setUncontrolledValue","handleChange","value","consoleOnce","updateValue","newVal","synthEvt","createSyntheticEvent","Event","cancelable","bubbles","useDynamicRefs","args","prefix","React","getter","refMap","key","get","createRef","set","getGetRef","Map","useEscapeKey","keyCode","stopImmediatePropagation","handleEscape","useForceRerender","updateState","useCallback","useObservedRef","_ref$deps","deps","nextValue","_toConsumableArray","useForwardedRef","forwardedRefOrRefs","forwardValueToRefs","forEach","globalId","useId","_ref2","idOverride","id","defaultId","setDefaultId","useGlobalId","useIsomorphicLayoutEffect","useLayoutEffect","apply","useMutationObserver","setValue","observer","MutationObserver","observe","disconnect","useObjectDependency","object","isEqual","usePoller","onPoll","_ref$interval","interval","_ref$immediate","immediate","savedCallback","isPolling","isVisibilityStateVisible","visibilityState","isVisible","setIsVisible","useVisibilityChange","poll","scheduleNextPoll","unscheduleNextPoll","setTimeout","clearTimeout","_savedCallback$curren","Promise","resolve","call","finally","usePrevious","useStateRef","initial","state","_setState","useValidation","handleValidation","isDirty","setIsDirty","onBlur","onChange"],"mappings":"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"}